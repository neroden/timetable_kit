#! /usr/bin/env python3
# amtrak/access.py
# Part of timetable_kit
# Copyright 2021, 2022 Nathanael Nerode.  Licensed under GNU Affero GPL v.3 or later.

"""
Make various dicts from station code to various station accessibility features.

Requires local copy of Amtrak stations database: That local copy is generated by "json_stations.py download"
This has very similar code to baggage.py
"""
from io import StringIO  # for parsing JSON
import json

import pandas as pd

from timetable_kit.amtrak.json_stations import (
    load_stations_json,
    load_station_details,
)

# These are mine
from timetable_kit.debug import set_debug_level, debug_print

# FIXME: this should be relative to something.
# base_dir = Path(__file__).parent
# station_stats_dir = base_dir / "station_stats"
# stations_csv_path = station_stats_dir / "json_stations.csv"
# bad_stations_path = base_dir / "bad_stations.csv"

# This is a global filled on first use
accessible_platform_dict = None
inaccessible_platform_dict = None


def station_has_inaccessible_platform(station_code: str) -> bool:
    """
    Does the station explicitly have an inaccessible platform?

    This excludes stations which don't say either way.

    Constructs and caches the data on first call.
    Requires that the JSON stations database already be downloaded.
    """
    if inaccessible_platform_dict is None:
        make_accessibility_dicts()
    return inaccessible_platform_dict[station_code]


def station_has_accessible_platform(station_code: str) -> bool:
    """
    Does this station explicitly have an accessible platform?

    This excludes stations which don't say either way.

    Constructs and caches the data on first call.
    Requires that the JSON stations database already be downloaded.
    """
    if accessible_platform_dict is None:
        make_accessibility_dicts()
    return accessible_platform_dict[station_code]


def make_accessibility_dicts() -> None:
    """
    Make dicts which map from station code to accessibility status.

    These are globals within this module.
    """
    stations_json = load_stations_json()

    # Have to set up a StringIO wrapper
    stations_json_as_file = StringIO(stations_json)
    # This line just works!
    stations = pd.io.json.read_json(stations_json_as_file, orient="records")
    station_list = stations["code"].array

    global accessible_platform_dict
    global inaccessible_platform_dict
    accessible_platform_dict = {}
    inaccessible_platform_dict = {}

    for code in station_list:
        station_details_json = load_station_details(code)
        if station_details_json in ["{}", "{}\n"]:  # Bad station
            debug_print(1, "Bad station details for", code, ": assuming nothing")
            accessible_platform_dict[code] = False
            inaccessible_platform_dict[code] = False
        else:
            parsed_json = json.loads(station_details_json)
            # Exactly five tabs in details, one of which is "accessibility".
            access_json = parsed_json["accessibility"]

            # First pass through for accessible platform:
            for x in access_json:
                # Each element looks like {"feature", "blahblahblah"}.
                if "feature" in x:
                    if x["feature"] in ["Accessible platform"]:
                        accessible_platform_dict[code] = True
                        break
            else:  # Did not break out of the loop
                accessible_platform_dict[code] = False

            # Second pass through for inaccessible platform:
            for x in access_json:
                if "feature" in x:
                    if x["feature"] in ["No accessible platform"]:
                        inaccessible_platform_dict[code] = True
                        break
            else:  # Did not break out of the loop
                inaccessible_platform_dict[code] = False

            if accessible_platform_dict[code] and inaccessible_platform_dict[code]:
                # Should never happen
                print("Platform both accessible and inaccessible at", code)
    print("Built accessible platform dicts")
    # Finally out of the loop
    return


# TESTING
if __name__ == "__main__":
    set_debug_level(2)
